<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>2C - Language Model Surprisal and EEG Data &mdash; ANCM 2025 0.1 documentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css?v=19f00094" />
      <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css?v=13237357" />
      <link rel="stylesheet" type="text/css" href="../_static/nbsphinx-code-cells.css" />

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../_static/jquery.js?v=5d32c60e"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../_static/documentation_options.js?v=2709fde1"></script>
        <script src="../_static/doctools.js?v=9a2dae69"></script>
        <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
        <script>let toggleHintShow = 'Click to show';</script>
        <script>let toggleHintHide = 'Click to hide';</script>
        <script>let toggleOpenOnPrint = 'true';</script>
        <script src="../_static/togglebutton.js?v=4a39c7ea"></script>
        <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
        <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
        <script>window.MathJax = {"tex": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true}, "options": {"ignoreHtmlClass": "tex2jax_ignore|mathjax_ignore|document", "processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
        <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="3 - Item Response Theory with Stan" href="../week_3/3_IRT_Stan.html" />
    <link rel="prev" title="2B - Representational Similarity with Story Reading fMRI data" href="2B_RSA_with_fMRI_Data.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            ANCM 2025
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Week 1:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../week_1/1_Logistic_regression_for_musical_tags.html">1 - Logistic Regression for Musical Tags</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Week 2:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="2A_Language_Model_Refresher.html">2A - Language model refresher</a></li>
<li class="toctree-l1"><a class="reference internal" href="2B_RSA_with_fMRI_Data.html">2B - Representational Similarity with Story Reading fMRI data</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">2C - Language Model Surprisal and EEG Data</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#Importing-libraries-and-downloading-data">Importing libraries and downloading data</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#QUESTION-2"><strong>QUESTION 2</strong></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#Training-the-TRFs-(or-not)">Training the TRFs (or not)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#Plotting-the-obtained-TRF-coefficients">Plotting the obtained TRF coefficients</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#QUESTION-3"><strong>QUESTION 3</strong></a></li>
</ul>
</li>
</ul>
</li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Week 3:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../week_3/3_IRT_Stan.html">3 - Item Response Theory with Stan</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Week 4:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../week_4/4_Vision%2C_Convolutions_and_Recurrence.html">4 - Vision, convolutions, recurrence</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Project Inspiration:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../project_ideas.html">Project Inspiration</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">ANCM 2025</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">2C - Language Model Surprisal and EEG Data</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/week_2/2C_LM_Surprisal_and_EEG_data.ipynb.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="2C---Language-Model-Surprisal-and-EEG-Data">
<h1>2C - Language Model Surprisal and EEG Data<a class="headerlink" href="#2C---Language-Model-Surprisal-and-EEG-Data" title="Link to this heading">ÔÉÅ</a></h1>
<p><a class="reference external" href="https://github.com/annabavaresco/ancm2025/blob/main/docs/week_2/2C_LM_Surprisal_and_EEG_data.ipynb"><img alt="View filled on Github" src="https://img.shields.io/static/v1.svg?logo=github&amp;label=Repo&amp;message=View%20On%20Github&amp;color=lightgrey" /></a> <a class="reference external" href="https://colab.research.google.com/github/annabavaresco/ancm2025/blob/main/docs/week_2/2C_LM_Surprisal_and_EEG_data.ipynb"><img alt="View filled in Colab" src="https://colab.research.google.com/assets/colab-badge.svg" /></a></p>
<p><em>by Jelle Zuidema (September 2022), with edits by Anna Bavaresco (July 2024)</em></p>
<hr class="docutils" />
<p>This notebook is based on Rasyan Ahmed‚Äôs master thesis code.</p>
<p>Today we‚Äôll be working on the EEG data collected by <a class="reference external" href="https://www.sciencedirect.com/science/article/pii/S0960982218301465">Broderick et al., 2018</a> while participants were listening to an audiobook. The authors were interested in the N400 component of event-related potentials.</p>
<p>What‚Äôs special about N400? It has consistently been shown to signal <em>surprisal</em>, which can roughly be defined as ‚Äòincongruence with the surrounding context‚Äô. To illustrate, if we read a sentence broccoli with a word that is completely out of context ‚Äì and therefore <em>surprising</em> ‚Äì our brains will signal this with a spike in the N400 component.</p>
<p>Broderick and colleagues, however, move away from this incongrous word paradigm and look at words during natural speech comprehension more in general. In particular, they ivestigate whether N400 is tracking the contextual semantic content of words while they are being processed. How do they do this? They construct word vectors representing how semantically dissimilar a word is to the preceding context, and then regress these vectors against EEG data.</p>
<p>Let‚Äôs briefly zoom in into how the authors computed these ‚Äòdissimilarity vectors‚Äô. Let‚Äôs consider the sentence ‚ÄúMary saw the dog as she walked past the garden‚Äù (this is a made-up example for illustration purposes). If we want to compute the dissimilarity vector for a word ‚Äì let‚Äôs say ‚Äòdog‚Äô ‚Äì as the authors did, we should first compute word embeddings for all the words in the sentence using word2vec and then do the following: 1. Select the word embedding corresponding to ‚Äòdog‚Äô 2. Compute the
average of the word embeddings from all the words preceding ‚Äòdog‚Äô (so here ‚ÄòMary‚Äô, ‚Äòsaw‚Äô, ‚Äòthe‚Äô) 3. Compute the Pearson correlation between the ‚Äòdog‚Äô vector and the average vector (form point 2) 4. Subtract the correlation from 1 (because we‚Äôre trying to compute <em>dissimilarity</em> and not <em>similarity</em>)</p>
<p>This semantic dissimilarity measure can be considered as a ‚Äòrepresentation of the meaning added to a sentence by that word‚Äô.</p>
<p>We‚Äôll look at how these vectors are used to learn us something about EEG responses later on in this notebook. For now, let‚Äôs focus on <em>semantic dissimilarity</em> and how it was operationalised by Broderick and colleagues.</p>
<p>###<strong>QUESTION 1</strong> Are there are any shortcomings with using word2vec vectors? Do you think that the contextualised vectors that we can get from more recent language models might be more suitable for the purpose? (‚ö†Ô∏è<em>Spoiler alert:</em> all these rhetorical questions seem to presuppose a ‚Äòyes‚Äô)</p>
<section id="Importing-libraries-and-downloading-data">
<h2>Importing libraries and downloading data<a class="headerlink" href="#Importing-libraries-and-downloading-data" title="Link to this heading">ÔÉÅ</a></h2>
<p>Here we‚Äôre simply importing some libraries and downloading the <code class="docutils literal notranslate"><span class="pre">.zip</span></code> files with the data that we‚Äôre going to use in this lab. Just run the cells below for now, you‚Äôll find out what you have downloaded in the next sections.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[ ]:
</pre></div>
</div>
<div class="input_area highlight-python notranslate"><div class="highlight"><pre><span></span><span class="o">%%</span><span class="n">capture</span>
<span class="err">!</span> <span class="n">pip</span> <span class="n">install</span> <span class="n">mne</span>
<span class="err">!</span> <span class="n">pip</span> <span class="n">install</span> <span class="o">-</span><span class="n">q</span> <span class="n">scipy</span>
</pre></div>
</div>
</div>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[ ]:
</pre></div>
</div>
<div class="input_area highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">scipy.io</span> <span class="k">as</span> <span class="nn">sio</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">mne</span>
<span class="kn">from</span> <span class="nn">mne.decoding</span> <span class="kn">import</span> <span class="n">ReceptiveField</span>
<span class="kn">from</span> <span class="nn">sklearn.model_selection</span> <span class="kn">import</span> <span class="n">KFold</span>
<span class="kn">from</span> <span class="nn">sklearn.preprocessing</span> <span class="kn">import</span> <span class="n">StandardScaler</span>
<span class="kn">from</span> <span class="nn">tqdm.auto</span> <span class="kn">import</span> <span class="n">tqdm</span>
<span class="kn">import</span> <span class="nn">random</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">from</span> <span class="nn">os.path</span> <span class="kn">import</span> <span class="n">join</span>
</pre></div>
</div>
</div>
<p>We are going to be working with the following files in this lab. In order to access them, click on the links below and then hit the ‚Äúadd shortcut to Google Drive‚Äù button. - <a class="reference external" href="https://drive.google.com/file/d/1ZWopKDEf1FPDciVPATcUrAkF8XY0WgK6/view?usp=sharing">Subject19.zip</a> - <a class="reference external" href="https://drive.google.com/file/d/1c04Z8YNUjoRkGfNu2zGQDM6gFpRs-Cab/view?usp=sharing">Stimuli.zip</a> - <a class="reference external" href="https://drive.google.com/file/d/1yF3PK94RFRxZyMuQHHOk8iS7yZMMJ15j/view?usp=sharing">vectors.zip</a> -
<a class="reference external" href="https://drive.google.com/file/d/1lXNhl3WUK48Juj0oA-itR_tkONdlK2G4/view?usp=sharing">results.zip</a></p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[ ]:
</pre></div>
</div>
<div class="input_area highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">google.colab</span> <span class="kn">import</span> <span class="n">drive</span>
<span class="n">drive</span><span class="o">.</span><span class="n">mount</span><span class="p">(</span><span class="s1">&#39;/content/drive&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Mounted at /content/drive
</pre></div></div>
</div>
<p>Let‚Äôs now unzip the files. You will need to update the following paths based on where the files are located in your Drive.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[ ]:
</pre></div>
</div>
<div class="input_area highlight-python notranslate"><div class="highlight"><pre><span></span><span class="err">!</span><span class="n">unzip</span> <span class="o">-</span><span class="n">qq</span> <span class="s1">&#39;/content/drive/MyDrive/PhD/ANCM/Lab Materials 2024/Subject19.zip&#39;</span>
<span class="err">!</span><span class="n">unzip</span> <span class="o">-</span><span class="n">qq</span> <span class="s1">&#39;/content/drive/MyDrive/PhD/ANCM/Lab Materials 2024/Stimuli.zip&#39;</span>
<span class="err">!</span><span class="n">unzip</span> <span class="o">-</span><span class="n">qq</span> <span class="s1">&#39;/content/drive/MyDrive/PhD/ANCM/Lab Materials 2024/vectors.zip&#39;</span>
<span class="err">!</span><span class="n">unzip</span> <span class="o">-</span><span class="n">qq</span> <span class="s1">&#39;/content/drive/MyDrive/PhD/ANCM/Lab Materials 2024/results.zip&#39;</span>
</pre></div>
</div>
</div>
<p>#Loading and preprocessing the EEG data</p>
<p>The following functions will make sure that the EEG data and the dissimilarity vectors we have unzipped are now properly loaded. More specifically, the functions below allow us to specify a list of participants and the model used to compute the word embeddings. For each participant, the functions will return: * the 128-channel EEG data (where channels correspond to the number of electrodes placed on subjects‚Äô sculps) * the 2-channel EEG data corresponding to the mastoids * the dissimilarity
vectors</p>
<p>Are you wondering what mastoids are?üëÄ They are bones that are part of our skulls, located behind our ears. Why do we care about them here? ü§î They are important for data <em>re-referencing</em>. We‚Äôll learn more about re-refering later on in the notebook.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[ ]:
</pre></div>
</div>
<div class="input_area highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1">#@title Helper functions for loading data</span>

<span class="k">def</span> <span class="nf">load_subject_data</span><span class="p">(</span><span class="n">subj_id</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">normalised_sim</span><span class="p">,</span> <span class="n">freq</span><span class="p">):</span>
  <span class="n">raw</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="n">ms</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="n">dis_vector</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1">#print(&#39;Load eeg &amp; dissimilarity values: subject: &#39;, sub, &quot;/&quot;, len(subs), end = &quot;\r&quot;, flush=True)</span>

  <span class="k">for</span> <span class="n">run</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">21</span><span class="p">):</span> <span class="c1"># for each run</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">sio</span><span class="o">.</span><span class="n">loadmat</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Subject</span><span class="si">{</span><span class="n">subj_id</span><span class="si">}</span><span class="s2">/Subject</span><span class="si">{</span><span class="n">subj_id</span><span class="si">}</span><span class="s2">_Run</span><span class="si">{</span><span class="n">run</span><span class="si">}</span><span class="s2">.mat&quot;</span> <span class="p">)</span>
    <span class="n">raw_run</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;eegData&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">T</span>
    <span class="n">ms_run</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;mastoids&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">T</span>
    <span class="n">words</span> <span class="o">=</span> <span class="n">sio</span><span class="o">.</span><span class="n">loadmat</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Stimuli/Text/Run</span><span class="si">{</span><span class="n">run</span><span class="si">}</span><span class="s2">.mat&quot;</span><span class="p">)</span>

    <span class="c1"># create list of word similaritys in order and normalise.</span>
    <span class="n">norm_flat_sim</span> <span class="o">=</span> <span class="p">[</span><span class="n">simz</span> <span class="o">*</span> <span class="n">normalised_sim</span> <span class="k">for</span> <span class="n">sentence</span> <span class="ow">in</span> <span class="n">sim</span><span class="p">[</span><span class="n">run</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">simz</span> <span class="ow">in</span> <span class="n">sentence</span><span class="p">]</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">norm_flat_sim</span><span class="p">)</span><span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">words</span><span class="p">[</span><span class="s1">&#39;onset_time&#39;</span><span class="p">]):</span>
      <span class="nb">print</span><span class="p">(</span><span class="n">subj_id</span><span class="p">,</span> <span class="n">run</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">norm_flat_sim</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">words</span><span class="p">[</span><span class="s1">&#39;onset_time&#39;</span><span class="p">]))</span>

            <span class="c1"># create empty vector of same size as the eeg</span>
    <span class="n">dis_vector_run</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="n">raw_run</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>

    <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;random_loc&#39;</span><span class="p">:</span>
      <span class="n">random_locations</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">raw_run</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="nb">len</span><span class="p">(</span><span class="n">norm_flat_sim</span><span class="p">))</span>


    <span class="c1"># for each word, find its onset, and then place it there in the empty vector.</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">norm_flat_sim</span><span class="p">)):</span>
      <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;random_loc&#39;</span><span class="p">:</span>
        <span class="n">on</span> <span class="o">=</span> <span class="n">random_locations</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="n">on</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">words</span><span class="p">[</span><span class="s1">&#39;onset_time&#39;</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="n">freq</span><span class="p">))</span>

      <span class="n">dis_vector_run</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">on</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">norm_flat_sim</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>

    <span class="n">raw</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">raw_run</span><span class="p">)</span>
    <span class="n">ms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ms_run</span><span class="p">)</span>
    <span class="n">dis_vector</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dis_vector_run</span><span class="p">)</span>

  <span class="k">return</span> <span class="n">raw</span><span class="p">,</span> <span class="n">ms</span><span class="p">,</span> <span class="n">dis_vector</span>

<span class="k">def</span> <span class="nf">load_eeg_and_disimilarlity_vector</span><span class="p">(</span><span class="n">sim</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">subjects</span><span class="p">,</span> <span class="n">freq</span><span class="p">,</span> <span class="n">norm</span><span class="p">):</span>

    <span class="c1"># flatten the similarity values (from 3D list to 1D list)</span>

    <span class="n">flat_sim</span> <span class="o">=</span> <span class="p">[</span><span class="n">word</span> <span class="k">for</span> <span class="n">sentence</span> <span class="ow">in</span> <span class="p">[</span><span class="n">sentence</span> <span class="k">for</span> <span class="n">run</span> <span class="ow">in</span> <span class="n">sim</span> <span class="k">for</span> <span class="n">sentence</span> <span class="ow">in</span> <span class="n">run</span><span class="p">]</span> <span class="k">for</span> <span class="n">word</span> <span class="ow">in</span> <span class="n">sentence</span><span class="p">]</span>

    <span class="c1"># normalize to the values of the broderick similarity values.</span>
    <span class="n">normalised_sim</span> <span class="o">=</span> <span class="n">norm</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">flat_sim</span><span class="p">)</span>

    <span class="c1">#</span>
    <span class="n">raw_subs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">ms_subs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">dis_vector_subs</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">sub</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="n">subjects</span><span class="p">):</span>  <span class="c1"># for each subject</span>
        <span class="n">raw</span><span class="p">,</span> <span class="n">ms</span><span class="p">,</span> <span class="n">dis_vector</span> <span class="o">=</span> <span class="n">load_subject_data</span><span class="p">(</span><span class="n">sub</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">normalised_sim</span><span class="p">,</span> <span class="n">freq</span><span class="p">)</span>
        <span class="n">raw_subs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">raw</span><span class="p">)</span>
        <span class="n">ms_subs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ms</span><span class="p">)</span>
        <span class="n">dis_vector_subs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dis_vector</span><span class="p">)</span>

    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Data successfully loaded!&#39;</span><span class="p">)</span>
    <span class="k">return</span><span class="p">(</span><span class="n">dis_vector_subs</span><span class="p">,</span> <span class="n">ms_subs</span><span class="p">,</span> <span class="n">raw_subs</span><span class="p">)</span>
<br/></pre></div>
</div>
</div>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[ ]:
</pre></div>
</div>
<div class="input_area highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">vector</span> <span class="o">=</span> <span class="s1">&#39;bert_4_False&#39;</span> <span class="c1"># use word likehoods obtained from a Bert model, with access to 4 prior words and no access to future context</span>
<span class="n">norm_val</span> <span class="o">=</span> <span class="mf">0.33820258789060476</span>
<span class="n">subs</span> <span class="o">=</span> <span class="p">[</span><span class="mi">19</span><span class="p">]</span>
<span class="n">sim</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">join</span><span class="p">(</span><span class="s1">&#39;vectors&#39;</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">vector</span><span class="si">}</span><span class="s2">.npy&quot;</span><span class="p">),</span> <span class="n">allow_pickle</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">sfreq</span> <span class="o">=</span> <span class="mi">128</span>
<span class="n">dis_vector</span><span class="p">,</span> <span class="n">raw_mastoids</span><span class="p">,</span> <span class="n">raw_eeg</span> <span class="o">=</span> <span class="n">load_eeg_and_disimilarlity_vector</span><span class="p">(</span><span class="n">sim</span><span class="p">,</span> <span class="n">vector</span><span class="p">,</span> <span class="n">subs</span><span class="p">,</span> <span class="n">sfreq</span><span class="p">,</span> <span class="n">norm_val</span><span class="p">)</span>
<br/></pre></div>
</div>
</div>
<div class="nboutput docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<script type="application/vnd.jupyter.widget-view+json">{"model_id": "54c56a905bc54d68b3f16bc74ccd1fde", "version_major": 2, "version_minor": 0}</script></div>
</div>
<div class="nboutput docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area stderr docutils container">
<div class="highlight"><pre>
&lt;ipython-input-5-1991b1a14af6&gt;:33: DeprecationWarning: Conversion of an array with ndim &gt; 0 to a scalar is deprecated, and will error in future. Ensure you extract a single element from your array before performing this operation. (Deprecated NumPy 1.25.)
  on = int(np.floor(words[&#39;onset_time&#39;][j] * freq))
</pre></div></div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Data successfully loaded!
</pre></div></div>
</div>
<p>Great, now we have our raw data and distance vectors successfully loaded. Next, we‚Äôll do some data preprocessing. We‚Äôll be using the <a class="reference external" href="https://mne.tools/stable/index.html">MNE</a> library for this. The main preprocessing operations which will be performed by the following functions are: * <em>re-referencing</em>: EEG electrodes record voltages that are relative to other voltages (recorded at other electrodes). In this sense, we are lacking a single ‚Äòreference‚Äô to interpret the voltages measured by the
electrodes. This is why we need to do some <em>re-referencing</em> of the EEG data. But what should be our point of reference? A common choice ‚Äì which we‚Äôll be implementing here ‚Äì is to use the mastoids as reference electrodes, because the brain activity they capture is somehow ‚Äòweaker‚Äô than the brain activity recorded by elsewhere-located electrodes * <em>filtering</em>: we‚Äôll be filtering out the signal outside the 1-8Hz bandwidth</p>
<p>Are you curious about the MNE functions used in the following functions? Then check out the <a class="reference external" href="https://mne.tools/stable/index.html">MNE documentation</a>!</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[ ]:
</pre></div>
</div>
<div class="input_area highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1">#@title Helper function for preprocessing</span>

<span class="k">def</span> <span class="nf">process_eeg</span><span class="p">(</span><span class="n">dis_vector</span><span class="p">,</span> <span class="n">raw_mastoids</span><span class="p">,</span> <span class="n">raw_eeg</span><span class="p">,</span> <span class="n">var_limit</span><span class="p">):</span>

    <span class="n">raws</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">20</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
    <span class="n">ms</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">20</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
    <span class="n">dv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">20</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
    <span class="n">filtered</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">20</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
    <span class="n">data</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">21</span><span class="p">):</span>

        <span class="c1"># load data of the prev cell</span>
        <span class="n">raws</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">raw_eeg</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">T</span>
        <span class="n">ms</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">raw_mastoids</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">T</span>
        <span class="n">dv</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">dis_vector</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">T</span>


        <span class="c1"># add mastoids as the last two channels.</span>
        <span class="n">raw</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">raw_eeg</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">raw_mastoids</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>


        <span class="n">montage</span> <span class="o">=</span> <span class="n">mne</span><span class="o">.</span><span class="n">channels</span><span class="o">.</span><span class="n">make_standard_montage</span><span class="p">(</span><span class="s1">&#39;biosemi128&#39;</span><span class="p">);</span>
        <span class="n">montage</span><span class="o">.</span><span class="n">ch_names</span> <span class="o">=</span> <span class="n">montage</span><span class="o">.</span><span class="n">ch_names</span> <span class="o">+</span> <span class="p">[</span><span class="s1">&#39;M1&#39;</span><span class="p">,</span> <span class="s1">&#39;M2&#39;</span><span class="p">]</span>
        <span class="n">montage</span><span class="o">.</span><span class="n">dig</span> <span class="o">=</span> <span class="n">montage</span><span class="o">.</span><span class="n">dig</span> <span class="o">+</span> <span class="p">[</span><span class="n">montage</span><span class="o">.</span><span class="n">dig</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span><span class="n">montage</span><span class="o">.</span><span class="n">dig</span><span class="p">[</span><span class="mi">5</span><span class="p">]]</span>


        <span class="c1"># info = mne.create_info(montage.ch_names[:130], sfreq, &#39;eeg&#39;, montage=montage)</span>
        <span class="n">info</span> <span class="o">=</span> <span class="n">mne</span><span class="o">.</span><span class="n">create_info</span><span class="p">(</span><span class="n">montage</span><span class="o">.</span><span class="n">ch_names</span><span class="p">[:</span><span class="mi">130</span><span class="p">],</span> <span class="n">sfreq</span><span class="p">,</span> <span class="s1">&#39;eeg&#39;</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">raw</span> <span class="o">=</span> <span class="n">mne</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">RawArray</span><span class="p">(</span><span class="n">raw</span><span class="p">,</span> <span class="n">info</span><span class="p">)</span>
        <span class="n">raw</span><span class="o">.</span><span class="n">add_channels</span>


        <span class="c1"># remove the standard reference mne sets upon it.</span>
        <span class="n">raw</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">mne</span><span class="o">.</span><span class="n">set_eeg_reference</span><span class="p">(</span><span class="n">raw</span><span class="p">,</span> <span class="p">[])</span>

        <span class="c1"># reference instead using the average of the last two channels (mastoids)</span>
        <span class="n">raw</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">mne</span><span class="o">.</span><span class="n">set_eeg_reference</span><span class="p">(</span><span class="n">raw</span><span class="p">,</span> <span class="n">montage</span><span class="o">.</span><span class="n">ch_names</span><span class="p">[</span><span class="mi">128</span><span class="p">:</span><span class="mi">130</span><span class="p">])</span>

        <span class="c1"># bandpass filter the data without the mastoids</span>

        <span class="n">raw</span> <span class="o">=</span> <span class="n">raw</span><span class="o">.</span><span class="n">drop_channels</span><span class="p">(</span><span class="n">montage</span><span class="o">.</span><span class="n">ch_names</span><span class="p">[</span><span class="mi">128</span><span class="p">:</span><span class="mi">130</span><span class="p">])</span>
        <span class="n">raw</span> <span class="o">=</span> <span class="n">raw</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">8</span><span class="p">)</span>

        <span class="n">test</span> <span class="o">=</span> <span class="n">raw</span><span class="o">.</span><span class="n">get_data</span><span class="p">()</span>

        <span class="n">var</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">channel</span><span class="p">[</span><span class="mi">1280</span><span class="p">:</span><span class="o">-</span><span class="mi">1280</span><span class="p">])</span> <span class="k">for</span> <span class="n">channel</span> <span class="ow">in</span> <span class="n">test</span><span class="p">]</span>
        <span class="n">raw</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;bads&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">montage</span><span class="o">.</span><span class="n">ch_names</span><span class="p">[:</span><span class="mi">128</span><span class="p">])[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">var</span><span class="p">[:</span><span class="mi">128</span><span class="p">])</span><span class="o">&gt;</span><span class="n">var_limit</span><span class="p">])</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

        <span class="n">raw</span><span class="o">.</span><span class="n">interpolate_bads</span><span class="p">()</span>

        <span class="n">filt</span> <span class="o">=</span> <span class="n">raw</span><span class="o">.</span><span class="n">get_data</span><span class="p">()</span>
        <span class="n">filtered</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">filt</span><span class="p">[:</span><span class="mi">128</span><span class="p">]</span><span class="o">.</span><span class="n">T</span>

    <span class="n">data</span><span class="p">[</span><span class="s1">&#39;raw&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">raws</span>
    <span class="n">data</span><span class="p">[</span><span class="s1">&#39;ms&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ms</span>
    <span class="n">data</span><span class="p">[</span><span class="s1">&#39;dv&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">dv</span>
    <span class="n">data</span><span class="p">[</span><span class="s1">&#39;filtered&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">filtered</span>


    <span class="k">return</span> <span class="n">data</span>
<br/></pre></div>
</div>
</div>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[ ]:
</pre></div>
</div>
<div class="input_area highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># remove the capture command if you want the function to print all its very verbose outputs :)</span>
<span class="o">%%</span><span class="n">capture</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">process_eeg</span><span class="p">(</span><span class="n">dis_vector</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">raw_mastoids</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">raw_eeg</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">100000</span><span class="p">)</span>
</pre></div>
</div>
</div>
<p>Now that we have loaded and processed the data, it is time to have a look at the original EEG measurements and the effects of preprocessing üëÄ The original data is available as <code class="docutils literal notranslate"><span class="pre">data['raw']</span></code>. The filter data can be accessed as <code class="docutils literal notranslate"><span class="pre">data['filterd']</span></code>.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[ ]:
</pre></div>
</div>
<div class="input_area highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">eeg_before</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;raw&#39;</span><span class="p">]</span>
<span class="n">eeg_after</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;filtered&#39;</span><span class="p">]</span>
</pre></div>
</div>
</div>
<p>Before plotting, let‚Äôs have a look at the data dimensionality and make sure we know what each dimension corresponds to.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[ ]:
</pre></div>
</div>
<div class="input_area highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">eeg_before</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">eeg_before</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
(20,)
(23257, 128)
</pre></div></div>
</div>
<p>Here: * 20 represents the number of trials (segments) that each participant undertook * 128 is the number of channels (electrodes) * 2285 are the time points per trial</p>
<section id="QUESTION-2">
<h3><strong>QUESTION 2</strong><a class="headerlink" href="#QUESTION-2" title="Link to this heading">ÔÉÅ</a></h3>
<p>Choose the EEG responses for one trial and plot them for one channel (of your choice) before and after preprocessing. Then describe, in rough outline, what preprocessing has done to the signal.</p>
<p><em>Hint</em>: you might want to focus on a subset of time points to have a ‚Äúcloser look‚Äù at the signal</p>
</section>
</section>
<section id="Training-the-TRFs-(or-not)">
<h2>Training the TRFs (or not)<a class="headerlink" href="#Training-the-TRFs-(or-not)" title="Link to this heading">ÔÉÅ</a></h2>
<p>Now that our data is preprocessed, let‚Äôs see how we can use it to get a cognitive model. Our goal is to obtain <em>temporal response functions</em> (TRFs)*. TRFs are linear models that describe the relationship between stimuli and responses. In our case, the stimuli are words and the responses are the EEG recordings. Therefore, we are looking for a function that links EEG responses to the presented words ‚Äì or better, their <em>surprisal</em>.</p>
<p>But how do we get these TRFs? The authors trained some ridge regression models to predict EEG responses based on distance vectors. If you are curious about the specific steps that can be used to train these regression models, you can have a look at the code below, but its detailed understanding is not important for this assignment.</p>
<p>Since training the models can be quite time consuming, we‚Äôll skip this step and look at the TRFs by loading some pre-computed coefficients.</p>
<hr class="docutils" />
<p>*If you find the concept of a TRF a bit hard to grasp, I would recommend looking at <a class="reference external" href="https://eelbrain.readthedocs.io/en/stable/auto_examples/temporal-response-functions/trf_intro.html#sphx-glr-auto-examples-temporal-response-functions-trf-intro-py">this</a> resource, which has some nice and clear visualisations.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[ ]:
</pre></div>
</div>
<div class="input_area highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1">#@title Helper functions for training the TRF</span>

<span class="k">def</span> <span class="nf">TRF</span><span class="p">(</span><span class="n">subject_data</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">save</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">shuffle</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">second_folder</span> <span class="o">=</span> <span class="s1">&#39;randoms/&#39;</span><span class="p">):</span>

    <span class="k">for</span> <span class="n">run</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">start</span><span class="p">,</span><span class="n">end</span><span class="p">)):</span>

        <span class="c1">#print(&#39;run&#39;, run)</span>
        <span class="n">scores_subs</span><span class="o">=</span><span class="p">[]</span>
        <span class="n">coefs_subs</span><span class="o">=</span><span class="p">[]</span>
        <span class="n">error_subs</span><span class="o">=</span><span class="p">[]</span>
        <span class="k">for</span> <span class="n">sub</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="n">subs</span><span class="p">):</span>

            <span class="c1"># run value as random seed. makes reproduction possible if we need extra info later on.</span>
            <span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="n">run</span><span class="p">)</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">subject_data</span><span class="p">[</span><span class="n">subs</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">sub</span><span class="p">)]</span>
            <span class="n">dv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;dv&#39;</span><span class="p">])</span>

            <span class="k">if</span> <span class="n">shuffle</span><span class="p">:</span>
                <span class="c1"># create a list of all disimilarity values.</span>
                <span class="n">ddv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">d</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">dv</span> <span class="k">if</span> <span class="n">d</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">])</span>

                <span class="c1"># shuffle this list.</span>
                <span class="n">random</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">ddv</span><span class="p">)</span>

                <span class="c1"># for each non 0 in real dissimilarity vector</span>
                <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dv</span><span class="p">)):</span>
                    <span class="k">if</span> <span class="n">dv</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>

                        <span class="c1"># add the i element of the shuffled list of dissimilarity values.</span>
                        <span class="n">dv</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">ddv</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                        <span class="n">i</span><span class="o">+=</span><span class="mi">1</span>

            <span class="n">Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;filterd&#39;</span><span class="p">])</span>

            <span class="c1"># normalisation method. basicly just subtracts the average and devides by the standerd deviations</span>
            <span class="n">scaler</span> <span class="o">=</span> <span class="n">StandardScaler</span><span class="p">()</span>           <span class="c1"># initalise scaler</span>
            <span class="n">scaler</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">Y</span><span class="p">)</span>                       <span class="c1"># finds the average and sd</span>
            <span class="n">Y</span> <span class="o">=</span> <span class="n">scaler</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">Y</span><span class="p">)</span>      <span class="c1"># scales each value.</span>


            <span class="c1">#Initialize the model</span>
            <span class="n">rf</span> <span class="o">=</span> <span class="n">ReceptiveField</span><span class="p">(</span><span class="n">tmin</span><span class="p">,</span> <span class="n">tmax</span><span class="p">,</span> <span class="n">sfreq</span><span class="p">,</span> <span class="n">feature_names</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;envelope&#39;</span><span class="p">],</span>
                                <span class="n">estimator</span><span class="o">=</span><span class="mf">1.</span><span class="p">,</span> <span class="n">scoring</span><span class="o">=</span><span class="s1">&#39;corrcoef&#39;</span><span class="p">)</span>

            <span class="c1"># calculate how many items there are between the delays</span>
            <span class="n">n_delays</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">tmax</span> <span class="o">-</span> <span class="n">tmin</span><span class="p">)</span> <span class="o">*</span> <span class="n">sfreq</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span>

            <span class="c1"># setup 5fold CV</span>
            <span class="n">n_splits</span> <span class="o">=</span> <span class="mi">5</span>
            <span class="n">cv</span> <span class="o">=</span> <span class="n">KFold</span><span class="p">(</span><span class="n">n_splits</span><span class="p">)</span>

            <span class="n">DV</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">dv</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">78</span><span class="p">:</span><span class="n">i</span><span class="p">,]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">78</span><span class="p">,</span><span class="n">dv</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])])</span>

            <span class="c1"># Simple linear regression for each time step using 5fold CV</span>
            <span class="n">coefs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_splits</span><span class="p">,</span> <span class="n">n_channels</span><span class="p">,</span> <span class="n">n_delays</span><span class="p">))</span>
            <span class="n">scores</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_splits</span><span class="p">,</span> <span class="n">n_channels</span><span class="p">))</span>

            <span class="n">err</span><span class="o">=</span> <span class="p">[]</span>
            <span class="c1"># Iterate through splits, fit the model, and predict/test on held-out data</span>
            <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="p">(</span><span class="n">train</span><span class="p">,</span> <span class="n">test</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">cv</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">dv</span><span class="p">)):</span>  <span class="c1"># split the data 4:1 (train:test) for each different way.</span>
                <span class="c1">#print(&#39;split %s / %s&#39; % (ii + 1, n_splits))</span>

                <span class="n">rf</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">dv</span><span class="p">[</span><span class="n">train</span><span class="p">],</span> <span class="n">Y</span><span class="p">[</span><span class="n">train</span><span class="p">])</span>

                <span class="n">scores</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="n">rf</span><span class="o">.</span><span class="n">score</span><span class="p">(</span><span class="n">dv</span><span class="p">[</span><span class="n">test</span><span class="p">],</span> <span class="n">Y</span><span class="p">[</span><span class="n">test</span><span class="p">])</span>
                <span class="c1"># coef_ is shape (n_outputs, n_features, n_delays). we only have 1 feature</span>
                <span class="n">coefs</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="n">rf</span><span class="o">.</span><span class="n">coef_</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:]</span>

                <span class="c1"># calculate errors</span>

                <span class="n">W</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">coefs</span><span class="p">[</span><span class="n">ii</span><span class="p">],</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># define Weights as the flipped coefs</span>
                <span class="c1">#print(test)</span>

                <span class="n">test</span><span class="o">=</span><span class="n">test</span><span class="p">[</span><span class="n">test</span><span class="o">&gt;=</span><span class="mi">78</span><span class="p">]</span> <span class="c1"># remove the first 78 values, as we dont have full data for them</span>
                <span class="n">test</span><span class="o">=</span><span class="n">test</span> <span class="o">-</span><span class="mi">78</span>
                <span class="c1">#print(test)</span>
                <span class="n">DV2</span> <span class="o">=</span> <span class="n">DV</span><span class="p">[</span><span class="n">test</span><span class="p">]</span> <span class="c1"># select only the dissimilarity values for the test set</span>
                <span class="n">real</span> <span class="o">=</span> <span class="n">Y</span><span class="p">[</span><span class="n">test</span><span class="p">]</span>

                <span class="n">DVs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">DV2</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">mask</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">DV2</span><span class="p">))</span> <span class="k">if</span> <span class="n">DVs</span><span class="p">[</span><span class="n">s</span><span class="p">]</span><span class="o">!=</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">DV2</span> <span class="o">=</span> <span class="n">DV2</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="c1"># remove all test cases with 0 dv values</span>
                <span class="n">real</span> <span class="o">=</span> <span class="n">real</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>

                <span class="n">pred</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">W</span> <span class="o">@</span> <span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">DV2</span><span class="p">])</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span> <span class="c1"># calculate predicted value.</span>

                <span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">real</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">SStot</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">real</span><span class="o">-</span><span class="n">m</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">SSreg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">pred</span><span class="o">-</span><span class="n">m</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">SSres</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">real</span><span class="o">-</span><span class="n">pred</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">r2</span> <span class="o">=</span> <span class="mi">1</span><span class="o">-</span><span class="p">(</span><span class="n">SSres</span><span class="o">/</span><span class="n">SStot</span><span class="p">)</span>
                <span class="n">errors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">SStot</span><span class="p">,</span><span class="n">SSreg</span><span class="p">,</span><span class="n">SSres</span><span class="p">,</span><span class="n">r2</span><span class="p">])</span>

                <span class="n">err</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">errors</span><span class="p">)</span>

            <span class="n">times</span> <span class="o">=</span> <span class="n">rf</span><span class="o">.</span><span class="n">delays_</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">rf</span><span class="o">.</span><span class="n">sfreq</span><span class="p">)</span>

            <span class="n">scores_subs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">scores</span><span class="p">)</span>
            <span class="n">coefs_subs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">coefs</span><span class="p">)</span>
            <span class="n">error_subs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">err</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">shuffle</span><span class="o">==</span><span class="kc">True</span> <span class="ow">and</span> <span class="n">save</span> <span class="ow">and</span> <span class="p">((</span><span class="n">end</span><span class="o">-</span><span class="n">start</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">):</span>
            <span class="c1"># save results</span>
            <span class="n">saveFunc</span><span class="p">(</span><span class="n">loc</span><span class="p">,</span> <span class="n">run_string</span> <span class="p">,</span> <span class="n">scores_subs</span><span class="p">,</span> <span class="n">coefs_subs</span><span class="p">,</span> <span class="n">error_subs</span><span class="p">,</span> <span class="n">length</span><span class="p">)</span>

    <span class="k">return</span><span class="p">(</span><span class="n">scores_subs</span><span class="p">,</span> <span class="n">coefs_subs</span><span class="p">,</span> <span class="n">error_subs</span><span class="p">)</span> <span class="c1"># save last run results</span>

<span class="k">def</span> <span class="nf">train</span><span class="p">(</span><span class="n">vector</span><span class="p">,</span> <span class="n">preprocess</span> <span class="o">=</span> <span class="mi">100000</span><span class="p">,</span> <span class="n">backup</span> <span class="o">=</span> <span class="s1">&#39;pearson&#39;</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">save</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">shuffle</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>

    <span class="k">if</span> <span class="n">vector</span> <span class="o">==</span> <span class="s1">&#39;random_loc&#39;</span><span class="p">:</span>
        <span class="n">similarity_location</span> <span class="o">=</span> <span class="n">vector_loc</span> <span class="o">+</span>  <span class="n">backup</span> <span class="o">+</span> <span class="s1">&#39;.npy&#39;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">similarity_location</span> <span class="o">=</span> <span class="n">vector_loc</span> <span class="o">+</span>  <span class="n">vector</span> <span class="o">+</span> <span class="s1">&#39;.npy&#39;</span>

    <span class="c1"># loads the similarity values</span>
    <span class="n">sim</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">similarity_location</span><span class="p">,</span> <span class="n">allow_pickle</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="n">dis_vector</span><span class="p">,</span> <span class="n">raw_mastoids</span><span class="p">,</span> <span class="n">raw_eeg</span> <span class="o">=</span> <span class="n">load_eeg_and_disimilarlity_vector</span><span class="p">(</span><span class="n">sim</span><span class="p">,</span> <span class="n">vector</span><span class="p">)</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">process_eeg</span><span class="p">(</span><span class="n">dis_vector</span><span class="p">,</span> <span class="n">raw_mastoids</span><span class="p">,</span> <span class="n">raw_eeg</span><span class="p">,</span> <span class="n">preprocess</span><span class="p">)</span>

    <span class="n">scores_subs</span><span class="p">,</span> <span class="n">coefs_subs</span><span class="p">,</span> <span class="n">error_subs</span> <span class="o">=</span> <span class="n">TRF</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="c1">#scores_subs, coefs_subs, error_subs = TRF(data, start=3, end=100, save=save, shuffle=True, second_folder)</span>

    <span class="k">if</span> <span class="n">end</span><span class="o">-</span><span class="n">start</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">combine_multi_runs</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">save</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">vector</span> <span class="o">==</span> <span class="s1">&#39;pearson&#39;</span><span class="p">:</span>
            <span class="n">run_string</span> <span class="o">=</span> <span class="n">vector</span> <span class="o">+</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">preprocess</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">vector</span><span class="p">[:</span><span class="mi">4</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;bert&#39;</span><span class="p">:</span>
            <span class="n">run_string</span> <span class="o">=</span> <span class="n">vector</span> <span class="o">+</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">preprocess</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">vector</span> <span class="o">==</span> <span class="s1">&#39;static&#39;</span><span class="p">:</span>
            <span class="n">run_string</span> <span class="o">=</span> <span class="n">vector</span> <span class="o">+</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">preprocess</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">vector</span> <span class="o">==</span> <span class="s1">&#39;random_loc&#39;</span><span class="p">:</span>
            <span class="n">run_string</span> <span class="o">=</span> <span class="n">vector</span> <span class="o">+</span> <span class="s1">&#39;(&#39;</span> <span class="o">+</span> <span class="n">backup</span> <span class="o">+</span> <span class="s2">&quot;)&quot;</span> <span class="o">+</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">preprocess</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">shuffle</span><span class="p">:</span>
            <span class="n">run_string</span> <span class="o">=</span> <span class="s1">&#39;shuffle(&#39;</span> <span class="o">+</span> <span class="n">vector</span> <span class="o">+</span> <span class="s1">&#39;)&#39;</span> <span class="o">+</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">preprocess</span><span class="p">)</span>

        <span class="n">saveFunc</span><span class="p">(</span><span class="n">results_folder</span><span class="p">,</span> <span class="n">run_string</span><span class="p">,</span> <span class="n">scores_subs</span><span class="p">,</span> <span class="n">coefs_subs</span><span class="p">,</span> <span class="n">error_subs</span><span class="p">,</span> <span class="n">end</span><span class="o">-</span><span class="n">start</span><span class="p">)</span>

    <span class="k">return</span><span class="p">(</span><span class="n">scores_subs</span><span class="p">,</span> <span class="n">coefs_subs</span><span class="p">,</span> <span class="n">error_subs</span><span class="p">)</span>

<span class="c1">#scores_subz, coefs_subz, error_subz = train(vector_loc, method,  999999999999999999)</span>
<br/></pre></div>
</div>
</div>
</section>
<section id="Plotting-the-obtained-TRF-coefficients">
<h2>Plotting the obtained TRF coefficients<a class="headerlink" href="#Plotting-the-obtained-TRF-coefficients" title="Link to this heading">ÔÉÅ</a></h2>
<p>Now we‚Äôll be having a look at some plots which will help us understand which TRFs have been learned by the models.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[ ]:
</pre></div>
</div>
<div class="input_area highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1">#@title Helper function for plotting</span>

<span class="k">def</span> <span class="nf">plot_curve</span><span class="p">(</span><span class="n">ch</span><span class="p">,</span> <span class="n">sd</span><span class="p">,</span> <span class="n">ax</span><span class="p">,</span> <span class="n">title</span><span class="p">,</span> <span class="n">plot_data</span><span class="p">,</span> <span class="n">multi_coefs_avg</span><span class="p">,</span> <span class="n">multi_coefs_std</span><span class="p">):</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">tup</span> <span class="ow">in</span> <span class="n">plot_data</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">tup</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;single&quot;</span><span class="p">:</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">times</span><span class="p">,</span><span class="n">coefs</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">ch</span><span class="p">],</span> <span class="n">label</span><span class="o">=</span> <span class="n">tup</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">i</span><span class="o">+=</span><span class="mi">1</span>

        <span class="k">elif</span> <span class="n">tup</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;multi&quot;</span><span class="p">:</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">multi_coefs_avg</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">ch</span><span class="p">],</span> <span class="n">label</span> <span class="o">=</span> <span class="n">tup</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="s2">&quot; mean&quot;</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">fill_between</span><span class="p">(</span><span class="n">times</span><span class="p">,</span><span class="n">multi_coefs_avg</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">ch</span><span class="p">]</span><span class="o">-</span><span class="n">multi_coefs_std</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">ch</span><span class="p">]</span><span class="o">*</span><span class="n">sd</span><span class="p">,</span> <span class="n">multi_coefs_avg</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">ch</span><span class="p">]</span><span class="o">+</span><span class="n">multi_coefs_std</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">ch</span><span class="p">]</span><span class="o">*</span><span class="n">sd</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span> <span class="n">label</span> <span class="o">=</span><span class="n">tup</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="s2">&quot; &quot;</span><span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">sd</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;sd&quot;</span><span class="p">)</span>
            <span class="n">j</span><span class="o">+=</span><span class="mi">0</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">axhline</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">ls</span><span class="o">=</span><span class="s1">&#39;--&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;black&#39;</span><span class="p">)</span>
    <span class="c1">#ax.set_ylim(-0.09 ,0.05)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">title</span><span class="o">=</span><span class="n">title</span><span class="p">)</span>
</pre></div>
</div>
</div>
<p>The next two cells will simply set some parameters and import the right coefficients. More specifically, we‚Äôll be importing coefficients for the original Broderick models (based on dissimilarity vectors, as explained at the beginning of the notebook) and for a model computed from BERT-derived word embeddings.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[ ]:
</pre></div>
</div>
<div class="input_area highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># select data to load</span>
<span class="n">sub</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">19</span><span class="p">])</span>
<span class="n">sun</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="n">plot_data</span> <span class="o">=</span> <span class="p">[]</span>

<span class="n">results_folder</span> <span class="o">=</span> <span class="s1">&#39;results/&#39;</span>

<span class="c1"># start/ end time of relevant time period of word onset.</span>
<span class="n">tmin</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">tmax</span> <span class="o">=</span> <span class="mf">0.6</span>

<span class="c1"># Broderick</span>
<span class="n">plot_data</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s2">&quot;pearson_100000.npy&quot;</span><span class="p">,</span><span class="s1">&#39;Broderick (1-8Hz)&#39;</span><span class="p">,</span><span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="s2">&quot;single&quot;</span><span class="p">))</span>

<span class="c1"># static</span>
<span class="c1">#plot_data.append((&quot;static_100000.npy&quot;,&quot;static&quot;,&quot;brown&quot;, &quot;single&quot;))</span>

<span class="c1"># bert_4_false</span>
<span class="n">plot_data</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s2">&quot;bert_4_False_100000.npy&quot;</span><span class="p">,</span><span class="s2">&quot;BERT4&quot;</span><span class="p">,</span> <span class="s2">&quot;red&quot;</span><span class="p">,</span> <span class="s2">&quot;single&quot;</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[ ]:
</pre></div>
</div>
<div class="input_area highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">coefs</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">scores</span> <span class="o">=</span> <span class="p">[]</span>

<span class="k">for</span> <span class="n">tup</span> <span class="ow">in</span> <span class="n">plot_data</span><span class="p">:</span>

    <span class="k">if</span> <span class="n">tup</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;single&quot;</span><span class="p">:</span>
        <span class="c1"># load the data of the subjects you want to include + square scores to get r2</span>
        <span class="n">coef</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">results_folder</span><span class="si">}</span><span class="s1">coefs/</span><span class="si">{</span><span class="n">tup</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)[</span><span class="n">sub</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">score</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">results_folder</span><span class="si">}</span><span class="s1">scores/</span><span class="si">{</span><span class="n">tup</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)[</span><span class="n">sub</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span>
        <span class="n">score</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan_to_num</span><span class="p">(</span><span class="n">score</span><span class="p">)</span>

        <span class="c1"># mean out the subject axis</span>
        <span class="n">coef</span> <span class="o">=</span> <span class="n">coef</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">score</span> <span class="o">=</span> <span class="n">score</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1"># mean out the cross validation axis</span>
        <span class="n">coef</span> <span class="o">=</span> <span class="n">coef</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">score</span> <span class="o">=</span> <span class="n">score</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="n">coefs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">coef</span><span class="p">)</span>
        <span class="n">scores</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">score</span><span class="p">)</span>

<span class="n">n_channels</span> <span class="o">=</span> <span class="n">coefs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">n_points</span> <span class="o">=</span>  <span class="n">coefs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

<span class="c1"># define a n_points long array that defines what time a coefficent belongs to.</span>
<span class="c1"># used as the x axis in plotmtrfs.</span>
<span class="n">times</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">n_points</span><span class="p">))</span><span class="o">/</span> <span class="mi">128</span>

<span class="n">montage</span> <span class="o">=</span>  <span class="n">mne</span><span class="o">.</span><span class="n">channels</span><span class="o">.</span><span class="n">make_standard_montage</span><span class="p">(</span><span class="s1">&#39;biosemi128&#39;</span><span class="p">)</span>
<span class="n">info</span> <span class="o">=</span> <span class="n">mne</span><span class="o">.</span><span class="n">create_info</span><span class="p">(</span><span class="n">montage</span><span class="o">.</span><span class="n">ch_names</span><span class="p">[:</span><span class="n">n_channels</span><span class="p">],</span> <span class="n">n_channels</span><span class="p">,</span> <span class="s1">&#39;eeg&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<p>Now we‚Äôll indeed be plotting the TRFs for the two different models of word surprisal.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[ ]:
</pre></div>
</div>
<div class="input_area highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">sd</span> <span class="o">=</span> <span class="mf">1.6</span>
<span class="n">pl</span> <span class="o">=</span><span class="mi">1</span>
<span class="n">nrow</span> <span class="o">=</span> <span class="mi">3</span>
<span class="n">ncol</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">widths</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mf">0.1</span><span class="p">,</span><span class="mf">0.1</span><span class="p">]</span>
<span class="n">heights</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">33</span><span class="p">,</span><span class="mf">0.33</span><span class="p">,</span><span class="mf">0.33</span><span class="p">]</span>
<span class="c1"># gr = grid.GridSpec(wspace= , hspace= width_ratios= , height_ratios= )</span>
<span class="n">gri</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;wspace&#39;</span><span class="p">:</span><span class="mf">0.5</span><span class="p">,</span><span class="s1">&#39;hspace&#39;</span><span class="p">:</span><span class="mf">0.5</span><span class="p">,</span><span class="s1">&#39;width_ratios&#39;</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span><span class="mf">0.1</span><span class="p">]}</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">nrow</span><span class="p">,</span><span class="n">ncol</span><span class="p">,</span> <span class="n">squeeze</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">gridspec_kw</span> <span class="o">=</span> <span class="n">gri</span><span class="p">)</span>

<span class="n">plot_curve</span><span class="p">(</span><span class="mi">84</span><span class="p">,</span><span class="n">sd</span><span class="p">,</span><span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span><span class="s1">&#39;fz&#39;</span><span class="p">,</span> <span class="n">plot_data</span><span class="p">,</span> <span class="n">coefs</span><span class="p">,</span> <span class="n">scores</span><span class="p">)</span>
<span class="n">plot_curve</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">sd</span><span class="p">,</span><span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span><span class="s1">&#39;cz&#39;</span><span class="p">,</span> <span class="n">plot_data</span><span class="p">,</span> <span class="n">coefs</span><span class="p">,</span> <span class="n">scores</span><span class="p">)</span>
<span class="n">plot_curve</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span><span class="n">sd</span><span class="p">,</span><span class="n">axes</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span><span class="s1">&#39;pz&#39;</span><span class="p">,</span> <span class="n">plot_data</span><span class="p">,</span> <span class="n">coefs</span><span class="p">,</span> <span class="n">scores</span><span class="p">)</span>
<span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s2">&quot;off&quot;</span><span class="p">)</span>
<span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s2">&quot;off&quot;</span><span class="p">)</span>
<span class="n">axes</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s2">&quot;off&quot;</span><span class="p">)</span>
<span class="n">handles</span><span class="p">,</span> <span class="n">labels</span> <span class="o">=</span> <span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">get_legend_handles_labels</span><span class="p">()</span>
<span class="n">fig</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">handles</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="s1">&#39;upper right&#39;</span><span class="p">,</span> <span class="n">bbox_to_anchor</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
<span class="n">fig</span><span class="o">.</span><span class="n">show</span><span class="p">();</span>
<br/></pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<img alt="../_images/week_2_2C_LM_Surprisal_and_EEG_data_30_0.png" src="../_images/week_2_2C_LM_Surprisal_and_EEG_data_30_0.png" />
</div>
</div>
<p>Are you wondering what ‚Äòfz‚Äô, ‚Äòcz‚Äô and ‚Äòpz‚Äô mean? They are standard ways of referring to EEG electrodes. The first letter refers to the brain lobe where the electrode is positioned (F for <em>frontal</em>, C for <em>central</em>, P for <em>parietal</em>). The second letter Z stands for ‚Äòzero‚Äô and indicates that the electrodes are placed on the midline sagittal plane of the skull. But why are we only looking at the Z-positioned electrodes and not at the other ones? The Z electrodes are often used as a point of
reference.</p>
<section id="QUESTION-3">
<h3><strong>QUESTION 3</strong><a class="headerlink" href="#QUESTION-3" title="Link to this heading">ÔÉÅ</a></h3>
<ol class="loweralpha simple">
<li><p>Study the temporal response functions you‚Äôve just plotted for Broderick‚Äôs model of word surprisal versus the BERT-based model (with 4 words prior context). Do you observe the N400 component (negative polarization approximately 400 ms after word onset) in some of the channels? Do you observe this polarisation for the same channels across models? Do you find differences between the two models?</p></li>
<li><p>Now consider the results you get with a model that simply assigns uniform surprisal values to all words (i.e., it does not distinguish between suprising or unsurpring words). You can find the data for this model in the <code class="docutils literal notranslate"><span class="pre">static_100000.npy</span></code> file. Does that model change your assessment of the performance of the Broderick and BERT models?</p></li>
</ol>
<p>Please write down your answers to all the questions in this assignment in a dedicated PDF. There is no page/word limit, but you are encouraged to keep your answers clear and concise.</p>
<script type="application/vnd.jupyter.widget-state+json">
{"25436375380249c09f8b964617964bb2": {"model_module": "@jupyter-widgets/controls", "model_module_version": "1.5.0", "model_name": "DescriptionStyleModel", "state": {"_model_module": "@jupyter-widgets/controls", "_model_module_version": "1.5.0", "_model_name": "DescriptionStyleModel", "_view_count": null, "_view_module": "@jupyter-widgets/base", "_view_module_version": "1.2.0", "_view_name": "StyleView", "description_width": ""}}, "2695babc42994ebba19f654e04e45313": {"model_module": "@jupyter-widgets/controls", "model_module_version": "1.5.0", "model_name": "ProgressStyleModel", "state": {"_model_module": "@jupyter-widgets/controls", "_model_module_version": "1.5.0", "_model_name": "ProgressStyleModel", "_view_count": null, "_view_module": "@jupyter-widgets/base", "_view_module_version": "1.2.0", "_view_name": "StyleView", "bar_color": null, "description_width": ""}}, "27dc346270374bfb96ff231a41afb46c": {"model_module": "@jupyter-widgets/controls", "model_module_version": "1.5.0", "model_name": "HTMLModel", "state": {"_dom_classes": [], "_model_module": "@jupyter-widgets/controls", "_model_module_version": "1.5.0", "_model_name": "HTMLModel", "_view_count": null, "_view_module": "@jupyter-widgets/controls", "_view_module_version": "1.5.0", "_view_name": "HTMLView", "description": "", "description_tooltip": null, "layout": "IPY_MODEL_a2701ebae54646c5bae24d6bd55e6ba7", "placeholder": "\u200b", "style": "IPY_MODEL_25436375380249c09f8b964617964bb2", "value": "100%"}}, "3b7003bf21364ceebe75b7a01fb42b6b": {"model_module": "@jupyter-widgets/controls", "model_module_version": "1.5.0", "model_name": "HTMLModel", "state": {"_dom_classes": [], "_model_module": "@jupyter-widgets/controls", "_model_module_version": "1.5.0", "_model_name": "HTMLModel", "_view_count": null, "_view_module": "@jupyter-widgets/controls", "_view_module_version": "1.5.0", "_view_name": "HTMLView", "description": "", "description_tooltip": null, "layout": "IPY_MODEL_3ceaad90c9004fc5a984db34252a83bc", "placeholder": "\u200b", "style": "IPY_MODEL_55d771caf80147a68965b42ee2c7f068", "value": "\u20071/1\u2007[00:02&lt;00:00,\u2007\u20072.77s/it]"}}, "3ceaad90c9004fc5a984db34252a83bc": {"model_module": "@jupyter-widgets/base", "model_module_version": "1.2.0", "model_name": "LayoutModel", "state": {"_model_module": "@jupyter-widgets/base", "_model_module_version": "1.2.0", "_model_name": "LayoutModel", "_view_count": null, "_view_module": "@jupyter-widgets/base", "_view_module_version": "1.2.0", "_view_name": "LayoutView", "align_content": null, "align_items": null, "align_self": null, "border": null, "bottom": null, "display": null, "flex": null, "flex_flow": null, "grid_area": null, "grid_auto_columns": null, "grid_auto_flow": null, "grid_auto_rows": null, "grid_column": null, "grid_gap": null, "grid_row": null, "grid_template_areas": null, "grid_template_columns": null, "grid_template_rows": null, "height": null, "justify_content": null, "justify_items": null, "left": null, "margin": null, "max_height": null, "max_width": null, "min_height": null, "min_width": null, "object_fit": null, "object_position": null, "order": null, "overflow": null, "overflow_x": null, "overflow_y": null, "padding": null, "right": null, "top": null, "visibility": null, "width": null}}, "54c56a905bc54d68b3f16bc74ccd1fde": {"model_module": "@jupyter-widgets/controls", "model_module_version": "1.5.0", "model_name": "HBoxModel", "state": {"_dom_classes": [], "_model_module": "@jupyter-widgets/controls", "_model_module_version": "1.5.0", "_model_name": "HBoxModel", "_view_count": null, "_view_module": "@jupyter-widgets/controls", "_view_module_version": "1.5.0", "_view_name": "HBoxView", "box_style": "", "children": ["IPY_MODEL_27dc346270374bfb96ff231a41afb46c", "IPY_MODEL_e098cd4f04b14e2c98ab46dba908b5c5", "IPY_MODEL_3b7003bf21364ceebe75b7a01fb42b6b"], "layout": "IPY_MODEL_ec8497b82c5f40c8963b6da70d458aa2"}}, "55d771caf80147a68965b42ee2c7f068": {"model_module": "@jupyter-widgets/controls", "model_module_version": "1.5.0", "model_name": "DescriptionStyleModel", "state": {"_model_module": "@jupyter-widgets/controls", "_model_module_version": "1.5.0", "_model_name": "DescriptionStyleModel", "_view_count": null, "_view_module": "@jupyter-widgets/base", "_view_module_version": "1.2.0", "_view_name": "StyleView", "description_width": ""}}, "7070bcf3df22490b96ac3668476d6599": {"model_module": "@jupyter-widgets/base", "model_module_version": "1.2.0", "model_name": "LayoutModel", "state": {"_model_module": "@jupyter-widgets/base", "_model_module_version": "1.2.0", "_model_name": "LayoutModel", "_view_count": null, "_view_module": "@jupyter-widgets/base", "_view_module_version": "1.2.0", "_view_name": "LayoutView", "align_content": null, "align_items": null, "align_self": null, "border": null, "bottom": null, "display": null, "flex": null, "flex_flow": null, "grid_area": null, "grid_auto_columns": null, "grid_auto_flow": null, "grid_auto_rows": null, "grid_column": null, "grid_gap": null, "grid_row": null, "grid_template_areas": null, "grid_template_columns": null, "grid_template_rows": null, "height": null, "justify_content": null, "justify_items": null, "left": null, "margin": null, "max_height": null, "max_width": null, "min_height": null, "min_width": null, "object_fit": null, "object_position": null, "order": null, "overflow": null, "overflow_x": null, "overflow_y": null, "padding": null, "right": null, "top": null, "visibility": null, "width": null}}, "a2701ebae54646c5bae24d6bd55e6ba7": {"model_module": "@jupyter-widgets/base", "model_module_version": "1.2.0", "model_name": "LayoutModel", "state": {"_model_module": "@jupyter-widgets/base", "_model_module_version": "1.2.0", "_model_name": "LayoutModel", "_view_count": null, "_view_module": "@jupyter-widgets/base", "_view_module_version": "1.2.0", "_view_name": "LayoutView", "align_content": null, "align_items": null, "align_self": null, "border": null, "bottom": null, "display": null, "flex": null, "flex_flow": null, "grid_area": null, "grid_auto_columns": null, "grid_auto_flow": null, "grid_auto_rows": null, "grid_column": null, "grid_gap": null, "grid_row": null, "grid_template_areas": null, "grid_template_columns": null, "grid_template_rows": null, "height": null, "justify_content": null, "justify_items": null, "left": null, "margin": null, "max_height": null, "max_width": null, "min_height": null, "min_width": null, "object_fit": null, "object_position": null, "order": null, "overflow": null, "overflow_x": null, "overflow_y": null, "padding": null, "right": null, "top": null, "visibility": null, "width": null}}, "e098cd4f04b14e2c98ab46dba908b5c5": {"model_module": "@jupyter-widgets/controls", "model_module_version": "1.5.0", "model_name": "FloatProgressModel", "state": {"_dom_classes": [], "_model_module": "@jupyter-widgets/controls", "_model_module_version": "1.5.0", "_model_name": "FloatProgressModel", "_view_count": null, "_view_module": "@jupyter-widgets/controls", "_view_module_version": "1.5.0", "_view_name": "ProgressView", "bar_style": "success", "description": "", "description_tooltip": null, "layout": "IPY_MODEL_7070bcf3df22490b96ac3668476d6599", "max": 1, "min": 0, "orientation": "horizontal", "style": "IPY_MODEL_2695babc42994ebba19f654e04e45313", "value": 1}}, "ec8497b82c5f40c8963b6da70d458aa2": {"model_module": "@jupyter-widgets/base", "model_module_version": "1.2.0", "model_name": "LayoutModel", "state": {"_model_module": "@jupyter-widgets/base", "_model_module_version": "1.2.0", "_model_name": "LayoutModel", "_view_count": null, "_view_module": "@jupyter-widgets/base", "_view_module_version": "1.2.0", "_view_name": "LayoutView", "align_content": null, "align_items": null, "align_self": null, "border": null, "bottom": null, "display": null, "flex": null, "flex_flow": null, "grid_area": null, "grid_auto_columns": null, "grid_auto_flow": null, "grid_auto_rows": null, "grid_column": null, "grid_gap": null, "grid_row": null, "grid_template_areas": null, "grid_template_columns": null, "grid_template_rows": null, "height": null, "justify_content": null, "justify_items": null, "left": null, "margin": null, "max_height": null, "max_width": null, "min_height": null, "min_width": null, "object_fit": null, "object_position": null, "order": null, "overflow": null, "overflow_x": null, "overflow_y": null, "padding": null, "right": null, "top": null, "visibility": null, "width": null}}}
</script></section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="2B_RSA_with_fMRI_Data.html" class="btn btn-neutral float-left" title="2B - Representational Similarity with Story Reading fMRI data" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="../week_3/3_IRT_Stan.html" class="btn btn-neutral float-right" title="3 - Item Response Theory with Stan" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright Anna Bavaresco 2025.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>